

## 15.1 基本概念


**规则：**机器学习中通常指语义明确、能描述数据分布所隐含的客观规律或领域概念、可写成“若…，则…”形式的逻辑规则。**规则学习**（rule leaning）：是从训练数据中学习出一组能用来对未见实例进行判别的规则。 形式化地看，一条规则形如：

规则学习的**优势**： （1）与神经网络、支持向量机这样的“黑箱模型”相比，规则学习具有更好的可解释性，能使用户更直观地对判别过程有所了解； （2）规则学习能更自然地在学习过程中引入领域知识； （3）逻辑规则的抽象描述能力在处理一些高度复杂的AI任务时具有显著的优势。

**覆盖**： 符合规则的样本称为被该规则覆盖。

**冲突：** 规则集合中的每条规则都可看作一一个子模型，规则集合是这些子模型的一个集成。当同一个示例被判别结果不同的多条规则覆盖时，称发生了“冲突”(confict)，解决冲突的办法称为“**冲突消解**”(conflict resolution).。

常用的**冲突消解策略**： （1）**投票法**：将判别相同的**规则数最多**的结果作为最终结果。 （2）**排序法**：在规则集合上定义一个顺序，在发生冲突时使用**排序最前的规则**，相应的规则学习过程称为“带序规则”(orderedrule)学习或“优先级规则”(priority rule)学习。 （3）**元规则法**：根据领域知识事先设定-些“元规则”(meta-rule),，即关于**规则的规则**，例如“发生冲突时使用长度最小的规则”，然后根据元规则的指导来使用规则集。

规则学习算法通常会设置一条“**默认规则”**(default rule)，由它来处理规则集合未覆盖的样本。

从形式语言表达能力而言，规则可分为两类： （1）“**命题规则**“(propositionalrule)：由“原子命题”(propositionalatom)和逻辑连接词“与”(∧)、“或” (V)、“非” (﹁)和“蕴含”(←)构成的简单陈述句； （2）“**一阶规则”**(first- order rule)/关系型规则（relational rule）：基本成分是能描述事物的属性或关系的“原子公式”(atomic formula)。 从形式语言系统的角度看，命题规则是一阶规则的特例，一阶规则的学习要比命题规则复杂的多。

## 15.2 序贯覆盖


规则学习的**目标**：产生一个能覆盖尽可能多的样例的规则集。 最直接的做法：“**序贯覆盖**”(sequential covering)，即逐条归纳：在训练集上每学到一条规则，就将该规则覆盖的训练样例去除，然后以剩下的训练样例组成训练集重复上述过程，由于每次只处理一部分数据，因此也被称为“**分治”(separate and-conquer)策略**。

序贯覆盖法的关键：如何从训练集学出单条规则。

对规则学习目标⊕，产生一条规则就是寻找最优的一组逻辑文字来构成规则体，这是一个搜索问题。 最简单的做法是从空规则“⊕←”开始，将正例类别作为规则头，再逐个遍历训练集中的每个属性及取值，尝试将其作为逻辑文字增加到规则体中，若能使当前规则体仅覆盖正例,则由此产生一条规则，然后去除已被覆盖的正例并基于剩余样本尝试生成下一条规则。

现实任务中一般有两种策略来产生规则： （1）“**自顶向下”(top-down)**，即从比较一般的规则开始，逐渐添加新文字以缩小规则覆盖范围，直到满足预定条件为止；亦称为**“生成-测试**”(generate-then-test)法，是规则逐渐“特化”(specialization)的过程。 覆盖范围从大往小搜索规则，更容易产生泛化性能较好的规则。 （2）“**自底向上”(bottom-up)**，即从比较特殊的规则开始，逐渐删除文字以扩大规则覆盖范围，直到满足条件为止;亦称为“**数据驱动**”(data driven)法，是规则逐渐“泛化”(generalization)的过程。

覆盖范围从小往大搜索规则，适合于训练样本较少的情形。前者对噪声的鲁棒性比后者要强得多。因此，在命题规则学习中通常使用第一种策略，而第二种策略在一阶规则学习这类假设空间非常复杂的任务上实用得多。

为了缓解陷入局部最优，“**集束搜索**”(beam search),：每轮保留最优的b个逻辑文字，在下一轮均用于构建候选集，再把候选集中最优的b个留待再下一轮使用。

## 15.3 剪枝优化


**剪枝(**pruning)：规则生成本质上是一个贪心搜索过程，需有一定的机制来缓解过拟合的风险，最常见的做法是剪枝(pruning)。

与决策树相似，剪枝可发生在规则生长过程中，即“预剪枝”，也可发生在规则产生后，即“后剪枝”。通常是基于某种性能度量指标来评估增/删逻辑文字前后的规则性能，或增/删规则前后的规则集性能,从而判断是否要进行剪枝。

剪枝还可借统计显著性检验来进行： 方法：**CN2算法**[Clark and Niblett,1989]：在预剪枝时，假设用规则集进行预测必须显著优于直接基于训练样例集后验概率分布进行预测。 CN2使用了似然率统计量(LikelihoodRatio Statistics,简称LRS)。

这实际上是一种信息量指标，衡量了规则(集)覆盖样例的分布与训练集经验分布的差别： LRS越大，说明采用规则(集)进行预测与直接使用训练集正、反例比率进行猜测的差别越大； LRS越小，说明规则(集)的效果越可能仅是偶然现象。 在数据量比较大的现实任务中，通常设置为在LRS很大(例如0.99)时CN2算法才停止规则(集)生长。

后剪枝最常用的策略是**“减错剪枝”**(Reduced Error Pruning,简称REP)： 其基本做法是：将样例集划分为训练集和验证集，从训练集上学得规则集R后进行多轮剪枝，在每一轮穷举所有 可能的剪枝操作，包括删除规则中某个文字、删除规则结尾文字、删除规则尾部多个文字、删除整条规则等，然后用验证集对剪枝产生的所有候选规则集进行评估保留最好的那个规则集进行下一轮剪枝，如此继续，直到无法通过剪枝提高验证集上的性能为止。 REP：复杂度是O(m^4)**IREP **(Incremental REP) ：复杂度O(mlog2m) 做法：在生成每条规则前，先将当前样例集划分为训练集和验证集，在训练集上生成一条规则r，立即在验证集上对其进行REP剪枝，得到规则r，将r覆盖的样例去除，在更新后的样例集上重复上述过程。REP是针对规则集进行剪枝，而IREP仅对单条规则进行剪枝，因此后者比前者更高效。

规则学习算法RIPPER：


![./figures/07ae395cf6e44e4e906eaf61b84f7577.png](./figures/07ae395cf6e44e4e906eaf61b84f7577.png)


 RIPPER中的后处理机制是为了在剪枝的基础上进一步提升性能。对R中的每条规则ri,，RIPPER为它产生两个变体：


![./figures/ef8454a03244448a8fe3f7d85edab28e.png](./figures/ef8454a03244448a8fe3f7d85edab28e.png)


RIPPER 的后处理优化过程将冗中的所 有规则放在一起重新加以优化，恰是通过全局的考虑来缓解贪心算法的局部性， 从而往往能得到更好的效果。

## 15.4 一阶规则学习


**关系数据**：直接描述样例间的关系。**背景知识：**由原样本属性转化而来的“色泽更深”“根蒂更蜷”等原子公式。

现实任务中并非 所有的领域知识都能容易地通过属性重构和函数约束来表达。

由样本类别转化而来的关于“更好”“﹁更好”的原子公式。**FOIL **(First-Order Inductive Learner) ：是著名的一阶规则学习算法，它遵循序贯覆盖框架且采用自顶向下的规则归纳策略。

FOIL 增益与决策树使用的信息增益不同，它仅考虑 正例的信息量，并且用新规则覆盖的正例数作为权重。

FOIL使用“FOIL增益”（FOIL gain）来选择文字：


![./figures/8683ef2a2b0d4e13a41cc7cf09843c87.png](./figures/8683ef2a2b0d4e13a41cc7cf09843c87.png)


 FOIL 可大致看作命题规则学习与归纳逻辑程序设计之间的过渡，其自顶 向下的规则生成过程不能支持函数和逻辑表达式嵌套?因此规则表达能力仍有 不足;但它是把命题规则学习过程通过变量替换等操作直接转化为一阶规则学 习?因此比→般归纳逻辑程序设计技术更高效.

## 15.5 归纳逻辑程序设计


**归纳逻辑程序设计**(Inductive Logic Programming,简称ILP)：在一阶规则学习中引入了函数和逻辑表达式嵌套一方面，这使得机器学习系统具备了更为强大的表达能力；另一方面，ILP可看作用机器学习技术来解决基于背景知识的逻辑程序(logic program)归纳，其学得的“规则”可被PROLOG等逻辑程序设计语言直接使用。

### 15.5.1 最小一般泛化


**归纳逻辑程序**设计采用自底向上的规则生成策略，直接将一个或多个正例所对应的具体事实(grounded fact)作为初始规则，再对规则逐步进行泛化以增加其对样例的覆盖率。泛化操作可以是将规则中的常量替换为逻辑变量，也可以是删除规则体中的某个文字。

**最小一般泛化**(Least General Generalization,简称LGG) ：用于将“特殊”规则转变为更“一般”的规则。

在归纳逻辑程序设计中，获得 LGG 之后，可将其看作单条规则加入规则集，最后再用前几节介绍的技术进一步优化。例如对规则集进行后剪技等.

### 15.5.2 逆归结


四种完备的逆归结操作，以规则形式p←q等价地表达pV﹁q，并假定用小写字母表示逻辑文字、大写字母表示合取式组成的逻辑子句：


![./figures/17b52d4975a741989cb1f16b8b0bd940.png](./figures/17b52d4975a741989cb1f16b8b0bd940.png)


归结、逆归结都能容易地扩展为一阶逻辑形式;与命题逻辑的主要不同之 处是，一阶逻辑的归结、逆归结通常需进行合一置换操作。

**“置换”**(substitution)是用某些项来替换逻辑表达式中的变量。

**“合一”**(unification)是用一种变量置换令两个或多个逻辑表达式相等。

**逆归结的一大特点**：能够自动发明新谓词，这些谓词可能对应于样例属性和背景知识中不存在的新知识，对知识发现与精化有重要意义。

在现实任务中， ILP系统通常先自底向上生成一组规则，然后再结合最小一般泛化与逆归结做进一步学习。

